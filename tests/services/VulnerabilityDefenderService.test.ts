/**
 * Unit tests for VulnerabilityDefenderService
 */

import { describe, it, expect, jest, beforeEach } from '@jest/globals';
import { VulnerabilityDefenderService } from '../../src/services/VulnerabilityDefenderService';
import { VulnerabilityDefender, CreateVulnerabilityRequest, UpdateVulnerabilityRequest } from '../../src/models/VulnerabilityDefender';
import { vulnerabilityDefenderRepository, PaginatedResponse } from '../../src/repositories/VulnerabilityDefenderRepository';
import { NotFoundError } from '../../src/utils/errorHandler';

// Mock logger
jest.mock('../../src/utils/logger', () => ({
  logger: {
    info: jest.fn(),
    warn: jest.fn(),
    error: jest.fn(),
    debug: jest.fn(),
    setContext: jest.fn(),
    clearContext: jest.fn()
  }
}));

// Mock repository
const mockRepository = {
  getById: jest.fn(),
  getAll: jest.fn(),
  create: jest.fn(),
  update: jest.fn(),
  delete: jest.fn(),
  exists: jest.fn()
};

jest.mock('../../src/repositories/VulnerabilityDefenderRepository', () => ({
  vulnerabilityDefenderRepository: mockRepository
}));

describe('VulnerabilityDefenderService', () => {
  let service: VulnerabilityDefenderService;

  const mockVulnerability: VulnerabilityDefender = {
    id: 'test-uuid-1234',
    name: 'CVE-2024-1234',
    description: 'Test vulnerability description',
    severity: 'High',
    cvssV3: 7.8,
    updatedOn: '2024-10-20T10:00:00Z'
  };

  beforeEach(() => {
    jest.clearAllMocks();
    service = new VulnerabilityDefenderService();
  });

  describe('getVulnerabilityById', () => {
    it('should retrieve vulnerability by ID', async () => {
      mockRepository.getById.mockResolvedValue(mockVulnerability);

      const result = await service.getVulnerabilityById('test-uuid-1234');

      expect(result).toEqual(mockVulnerability);
      expect(mockRepository.getById).toHaveBeenCalledWith('test-uuid-1234');
    });

    it('should throw NotFoundError when vulnerability does not exist', async () => {
      mockRepository.getById.mockRejectedValue(
        new NotFoundError('Vulnerability', 'non-existent-id')
      );

      await expect(service.getVulnerabilityById('non-existent-id')).rejects.toThrow(NotFoundError);
    });
  });

  describe('getAllVulnerabilities', () => {
    it('should retrieve all vulnerabilities without filters', async () => {
      const mockResponse: PaginatedResponse<VulnerabilityDefender> = {
        items: [mockVulnerability],
        hasMore: false,
        count: 1
      };

      mockRepository.getAll.mockResolvedValue(mockResponse);

      const result = await service.getAllVulnerabilities();

      expect(result.items).toHaveLength(1);
      expect(result.items[0]).toEqual(mockVulnerability);
      expect(result.hasMore).toBe(false);
      expect(mockRepository.getAll).toHaveBeenCalledWith(undefined, undefined);
    });

    it('should retrieve vulnerabilities with name filter', async () => {
      const mockResponse: PaginatedResponse<VulnerabilityDefender> = {
        items: [mockVulnerability],
        hasMore: false,
        count: 1
      };

      mockRepository.getAll.mockResolvedValue(mockResponse);

      const result = await service.getAllVulnerabilities({ name: 'CVE-2024' });

      expect(result.items).toHaveLength(1);
      expect(mockRepository.getAll).toHaveBeenCalledWith(
        { name: 'CVE-2024' },
        undefined
      );
    });

    it('should retrieve vulnerabilities with severity filter', async () => {
      const mockResponse: PaginatedResponse<VulnerabilityDefender> = {
        items: [mockVulnerability],
        hasMore: false,
        count: 1
      };

      mockRepository.getAll.mockResolvedValue(mockResponse);

      const result = await service.getAllVulnerabilities({ severity: ['High', 'Critical'] });

      expect(result.items).toHaveLength(1);
      expect(mockRepository.getAll).toHaveBeenCalledWith(
        { severity: ['High', 'Critical'] },
        undefined
      );
    });

    it('should retrieve vulnerabilities with date range filter', async () => {
      const mockResponse: PaginatedResponse<VulnerabilityDefender> = {
        items: [mockVulnerability],
        hasMore: false,
        count: 1
      };

      mockRepository.getAll.mockResolvedValue(mockResponse);

      const result = await service.getAllVulnerabilities({
        updatedOnFrom: '2024-10-01T00:00:00Z',
        updatedOnTo: '2024-10-31T23:59:59Z'
      });

      expect(result.items).toHaveLength(1);
      expect(mockRepository.getAll).toHaveBeenCalledWith(
        {
          updatedOnFrom: '2024-10-01T00:00:00Z',
          updatedOnTo: '2024-10-31T23:59:59Z'
        },
        undefined
      );
    });

    it('should handle pagination', async () => {
      const mockResponse: PaginatedResponse<VulnerabilityDefender> = {
        items: [mockVulnerability],
        hasMore: true,
        count: 1,
        continuationToken: 'next-token'
      };

      mockRepository.getAll.mockResolvedValue(mockResponse);

      const result = await service.getAllVulnerabilities(
        {},
        { pageSize: 10, continuationToken: 'token' }
      );

      expect(result.hasMore).toBe(true);
      expect(result.continuationToken).toBe('next-token');
      expect(mockRepository.getAll).toHaveBeenCalledWith(
        {},
        { pageSize: 10, continuationToken: 'token' }
      );
    });
  });

  describe('createVulnerability', () => {
    it('should create a new vulnerability', async () => {
      const createRequest: CreateVulnerabilityRequest = {
        name: 'CVE-2024-1234',
        description: 'Test vulnerability',
        severity: 'High',
        cvssV3: 7.8,
        updatedOn: '2024-10-20T10:00:00Z'
      };

      mockRepository.create.mockResolvedValue(mockVulnerability);

      const result = await service.createVulnerability(createRequest);

      expect(result).toEqual(mockVulnerability);
      expect(mockRepository.create).toHaveBeenCalledWith(createRequest);
    });

    it('should propagate validation errors from repository', async () => {
      const createRequest: CreateVulnerabilityRequest = {
        name: 'CVE-2024-1234',
        severity: 'High',
        updatedOn: '2024-10-20T10:00:00Z'
      };

      mockRepository.create.mockRejectedValue(
        new Error('Validation error')
      );

      await expect(service.createVulnerability(createRequest)).rejects.toThrow('Validation error');
    });
  });

  describe('updateVulnerability', () => {
    it('should update an existing vulnerability', async () => {
      const updateRequest: UpdateVulnerabilityRequest = {
        severity: 'Critical',
        cvssV3: 9.0
      };

      const updatedVulnerability = { ...mockVulnerability, severity: 'Critical', cvssV3: 9.0 };
      mockRepository.update.mockResolvedValue(updatedVulnerability);

      const result = await service.updateVulnerability('test-uuid-1234', updateRequest);

      expect(result.severity).toBe('Critical');
      expect(result.cvssV3).toBe(9.0);
      expect(mockRepository.update).toHaveBeenCalledWith('test-uuid-1234', updateRequest);
    });

    it('should throw NotFoundError when vulnerability does not exist', async () => {
      mockRepository.update.mockRejectedValue(
        new NotFoundError('Vulnerability', 'non-existent-id')
      );

      await expect(
        service.updateVulnerability('non-existent-id', { severity: 'Critical' })
      ).rejects.toThrow(NotFoundError);
    });
  });

  describe('deleteVulnerability', () => {
    it('should delete a vulnerability', async () => {
      mockRepository.delete.mockResolvedValue(undefined);

      await expect(service.deleteVulnerability('test-uuid-1234')).resolves.not.toThrow();

      expect(mockRepository.delete).toHaveBeenCalledWith('test-uuid-1234');
    });

    it('should throw NotFoundError when vulnerability does not exist', async () => {
      mockRepository.delete.mockRejectedValue(
        new NotFoundError('Vulnerability', 'non-existent-id')
      );

      await expect(service.deleteVulnerability('non-existent-id')).rejects.toThrow(NotFoundError);
    });
  });

  describe('vulnerabilityExists', () => {
    it('should return true when vulnerability exists', async () => {
      mockRepository.exists.mockResolvedValue(true);

      const result = await service.vulnerabilityExists('test-uuid-1234');

      expect(result).toBe(true);
      expect(mockRepository.exists).toHaveBeenCalledWith('test-uuid-1234');
    });

    it('should return false when vulnerability does not exist', async () => {
      mockRepository.exists.mockResolvedValue(false);

      const result = await service.vulnerabilityExists('non-existent-id');

      expect(result).toBe(false);
    });
  });
});
