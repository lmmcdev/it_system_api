/**
 * Unit tests for VulnerabilityDefenderRepository
 */

import { describe, it, expect, jest, beforeEach } from '@jest/globals';
import { CreateVulnerabilityRequest, UpdateVulnerabilityRequest } from '../../src/models/VulnerabilityDefender';
import { NotFoundError, ServiceError, ValidationError, ConflictError } from '../../src/utils/errorHandler';

// Create mock functions with correct types
const mockRead: any = jest.fn();
const mockCreate: any = jest.fn();
const mockReplace: any = jest.fn();
const mockDelete: any = jest.fn();
const mockFetchNext: any = jest.fn();
const mockQuery: any = jest.fn();

// Mock CosmosDB
jest.mock('@azure/cosmos', () => ({
  CosmosClient: jest.fn().mockImplementation(() => ({
    database: jest.fn().mockReturnValue({
      container: jest.fn().mockReturnValue({
        item: jest.fn().mockImplementation(() => ({
          read: (...args: any[]) => mockRead(...args),
          replace: (...args: any[]) => mockReplace(...args),
          delete: (...args: any[]) => mockDelete(...args)
        })),
        items: {
          query: (...args: any[]) => mockQuery(...args),
          create: (...args: any[]) => mockCreate(...args)
        }
      })
    })
  }))
}));

// Mock uuid
jest.mock('uuid', () => ({
  v4: jest.fn(() => 'test-uuid-1234')
}));

// Mock logger
jest.mock('../../src/utils/logger', () => ({
  logger: {
    info: jest.fn(),
    warn: jest.fn(),
    error: jest.fn(),
    debug: jest.fn(),
    setContext: jest.fn(),
    clearContext: jest.fn()
  }
}));

// Mock config
jest.mock('../../src/config/environment', () => ({
  config: {
    cosmos: {
      endpoint: 'https://test.documents.azure.com:443/',
      key: 'test-key',
      databaseId: 'test-db',
      vulnerabilitiesDefenderContainerId: 'vulnerabilities_defender'
    }
  }
}));

// Import the repository after mocks are set up
import { VulnerabilityDefenderRepository } from '../../src/repositories/VulnerabilityDefenderRepository';

describe('VulnerabilityDefenderRepository', () => {
  let repository: VulnerabilityDefenderRepository;

  // CosmosDB document structure (nested under "value")
  const mockCosmosDocument = {
    id: 'test-uuid-1234',
    value: {
      id: 'test-uuid-1234',
      name: 'CVE-2024-1234',
      description: 'Test vulnerability description',
      severity: 'High',
      cvssV3: 7.8,
      exploitabilityLevel: 'Functional',
      exploitTypes: ['Exploit'],
      publicExploit: true,
      exploitInKit: false,
      hasExploit: true,
      publishedOn: '2024-10-01T00:00:00Z',
      updatedOn: '2024-10-20T10:00:00Z',
      weaknesses: ['CWE-79'],
      references: ['https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-1234'],
      relatedComponent: 'test-component',
      cvssV3Vector: 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H',
      cvssV3Base: 7.8
    },
    _rid: 'test-rid',
    _etag: '"test-etag"',
    _ts: 1729425600
  };

  beforeEach(() => {
    jest.clearAllMocks();

    // Setup query iterator mock
    mockQuery.mockReturnValue({
      fetchNext: mockFetchNext
    });

    repository = new VulnerabilityDefenderRepository();
  });

  describe('getById', () => {
    it('should retrieve vulnerability by ID', async () => {
      mockRead.mockResolvedValue({
        resource: mockCosmosDocument,
        requestCharge: 1.0
      });

      const result = await repository.getById('test-uuid-1234');

      expect(result).toMatchObject({
        id: 'test-uuid-1234',
        name: 'CVE-2024-1234',
        severity: 'High'
      });
    });

    it('should throw NotFoundError when vulnerability does not exist', async () => {
      mockRead.mockResolvedValue({
        resource: undefined,
        requestCharge: 1.0
      });

      await expect(repository.getById('non-existent-id')).rejects.toThrow(NotFoundError);
    });

    it('should handle 404 error from CosmosDB', async () => {
      const error = new Error('Not found') as any;
      error.code = 404;
      mockRead.mockRejectedValue(error);

      await expect(repository.getById('non-existent-id')).rejects.toThrow(NotFoundError);
    });

    it('should handle 409 conflict error', async () => {
      const error = new Error('Conflict') as any;
      error.code = 409;
      mockRead.mockRejectedValue(error);

      await expect(repository.getById('test-id')).rejects.toThrow(ConflictError);
    });

    it('should handle 429 throttling error', async () => {
      const error = new Error('Too many requests') as any;
      error.code = 429;
      error.retryAfterInMilliseconds = 1000;
      mockRead.mockRejectedValue(error);

      await expect(repository.getById('test-id')).rejects.toThrow(ServiceError);
    });
  });

  describe('getAll', () => {
    it('should retrieve all vulnerabilities without filters', async () => {
      mockFetchNext.mockResolvedValue({
        resources: [mockCosmosDocument],
        requestCharge: 2.5,
        hasMoreResults: false
      });

      const result = await repository.getAll();

      expect(result.items).toHaveLength(1);
      expect(result.items[0].name).toBe('CVE-2024-1234');
      expect(result.hasMore).toBe(false);
      expect(result.count).toBe(1);
    });

    it('should filter by name', async () => {
      mockFetchNext.mockResolvedValue({
        resources: [mockCosmosDocument],
        requestCharge: 2.5,
        hasMoreResults: false
      });

      const result = await repository.getAll({ name: 'CVE-2024' });

      expect(result.items).toHaveLength(1);
      expect(mockQuery).toHaveBeenCalledWith(
        expect.objectContaining({
          query: expect.stringContaining('CONTAINS(LOWER(c["value"]["name"]), LOWER(@name))')
        }),
        expect.any(Object)
      );
    });

    it('should filter by severity', async () => {
      mockFetchNext.mockResolvedValue({
        resources: [mockCosmosDocument],
        requestCharge: 2.5,
        hasMoreResults: false
      });

      const result = await repository.getAll({ severity: ['High', 'Critical'] });

      expect(result.items).toHaveLength(1);
      expect(mockQuery).toHaveBeenCalledWith(
        expect.objectContaining({
          query: expect.stringContaining('c["value"]["severity"]')
        }),
        expect.any(Object)
      );
    });

    it('should filter by date range', async () => {
      mockFetchNext.mockResolvedValue({
        resources: [mockCosmosDocument],
        requestCharge: 2.5,
        hasMoreResults: false
      });

      const result = await repository.getAll({
        updatedOnFrom: '2024-10-01T00:00:00Z',
        updatedOnTo: '2024-10-31T23:59:59Z'
      });

      expect(result.items).toHaveLength(1);
    });

    it('should validate invalid severity', async () => {
      await expect(
        repository.getAll({ severity: ['Invalid'] })
      ).rejects.toThrow(ValidationError);
    });

    it('should validate invalid date format', async () => {
      await expect(
        repository.getAll({ updatedOnFrom: 'invalid-date' })
      ).rejects.toThrow(ValidationError);
    });

    it('should handle pagination', async () => {
      mockFetchNext.mockResolvedValue({
        resources: [mockCosmosDocument],
        requestCharge: 2.5,
        hasMoreResults: true,
        continuationToken: 'next-token'
      });

      const result = await repository.getAll({}, { pageSize: 10 });

      expect(result.hasMore).toBe(true);
      expect(result.continuationToken).toBe('next-token');
    });
  });

  describe('create', () => {
    it('should create a new vulnerability', async () => {
      const createRequest: CreateVulnerabilityRequest = {
        name: 'CVE-2024-1234',
        description: 'Test vulnerability',
        severity: 'High',
        cvssV3: 7.8,
        updatedOn: '2024-10-20T10:00:00Z'
      };

      mockCreate.mockResolvedValue({
        resource: mockCosmosDocument,
        requestCharge: 5.0
      });

      const result = await repository.create(createRequest);

      expect(result.name).toBe('CVE-2024-1234');
      expect(result.severity).toBe('High');
      expect(mockCreate).toHaveBeenCalledWith(
        expect.objectContaining({
          id: expect.any(String),
          value: expect.objectContaining({
            name: 'CVE-2024-1234',
            severity: 'High'
          })
        })
      );
    });

    it('should validate required fields', async () => {
      const invalidRequest: any = {
        name: 'CVE-2024-1234'
        // Missing severity and updatedOn
      };

      await expect(repository.create(invalidRequest)).rejects.toThrow(ValidationError);
    });

    it('should validate severity value', async () => {
      const invalidRequest: CreateVulnerabilityRequest = {
        name: 'CVE-2024-1234',
        severity: 'InvalidSeverity' as any,
        updatedOn: '2024-10-20T10:00:00Z'
      };

      await expect(repository.create(invalidRequest)).rejects.toThrow(ValidationError);
    });

    it('should validate CVSS score range', async () => {
      const invalidRequest: CreateVulnerabilityRequest = {
        name: 'CVE-2024-1234',
        severity: 'High',
        cvssV3: 11.0, // Invalid: > 10
        updatedOn: '2024-10-20T10:00:00Z'
      };

      await expect(repository.create(invalidRequest)).rejects.toThrow(ValidationError);
    });

    it('should handle 409 conflict on duplicate ID', async () => {
      const error = new Error('Conflict') as any;
      error.code = 409;
      mockCreate.mockRejectedValue(error);

      const createRequest: CreateVulnerabilityRequest = {
        name: 'CVE-2024-1234',
        severity: 'High',
        updatedOn: '2024-10-20T10:00:00Z'
      };

      await expect(repository.create(createRequest)).rejects.toThrow(ConflictError);
    });
  });

  describe('update', () => {
    it('should update an existing vulnerability', async () => {
      mockRead.mockResolvedValue({
        resource: mockCosmosDocument,
        requestCharge: 1.0
      });

      mockReplace.mockResolvedValue({
        resource: { ...mockCosmosDocument, value: { ...mockCosmosDocument.value, severity: 'Critical' } },
        requestCharge: 2.0
      });

      const updateRequest: UpdateVulnerabilityRequest = {
        severity: 'Critical'
      };

      const result = await repository.update('test-uuid-1234', updateRequest);

      expect(result.severity).toBe('Critical');
      expect(mockReplace).toHaveBeenCalled();
    });

    it('should throw NotFoundError when vulnerability does not exist', async () => {
      mockRead.mockResolvedValue({
        resource: undefined,
        requestCharge: 1.0
      });

      await expect(
        repository.update('non-existent-id', { severity: 'Critical' })
      ).rejects.toThrow(NotFoundError);
    });

    it('should validate severity value on update', async () => {
      await expect(
        repository.update('test-id', { severity: 'InvalidSeverity' as any })
      ).rejects.toThrow(ValidationError);
    });

    it('should validate CVSS score on update', async () => {
      await expect(
        repository.update('test-id', { cvssV3: -1.0 })
      ).rejects.toThrow(ValidationError);
    });
  });

  describe('delete', () => {
    it('should delete a vulnerability', async () => {
      mockDelete.mockResolvedValue({
        requestCharge: 1.0
      });

      await expect(repository.delete('test-uuid-1234')).resolves.not.toThrow();

      expect(mockDelete).toHaveBeenCalled();
    });

    it('should throw NotFoundError when vulnerability does not exist', async () => {
      const error = new Error('Not found') as any;
      error.code = 404;
      mockDelete.mockRejectedValue(error);

      await expect(repository.delete('non-existent-id')).rejects.toThrow(NotFoundError);
    });

    it('should handle 409 conflict error', async () => {
      const error = new Error('Conflict') as any;
      error.code = 409;
      mockDelete.mockRejectedValue(error);

      await expect(repository.delete('test-id')).rejects.toThrow(ConflictError);
    });
  });

  describe('exists', () => {
    it('should return true when vulnerability exists', async () => {
      mockRead.mockResolvedValue({
        resource: mockCosmosDocument,
        requestCharge: 1.0
      });

      const result = await repository.exists('test-uuid-1234');

      expect(result).toBe(true);
    });

    it('should return false when vulnerability does not exist', async () => {
      mockRead.mockResolvedValue({
        resource: undefined,
        requestCharge: 1.0
      });

      const result = await repository.exists('non-existent-id');

      expect(result).toBe(false);
    });
  });
});