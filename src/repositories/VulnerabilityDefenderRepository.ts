/**
 * CosmosDB repository for VulnerabilityDefender data access
 * Handles all CosmosDB CRUD operations with proper error handling, pagination, and query tracing
 */

import { CosmosClient, Container, Database } from '@azure/cosmos';
import {
  VulnerabilityDefender,
  VulnerabilityDefenderDocument,
  VulnerabilityDefenderData,
  VulnerabilityValidation,
  CreateVulnerabilityRequest,
  UpdateVulnerabilityRequest
} from '../models/VulnerabilityDefender';
import { config } from '../config/environment';
import { logger } from '../utils/logger';
import { NotFoundError, ServiceError, ValidationError, ConflictError } from '../utils/errorHandler';
import { v4 as uuidv4 } from 'uuid';

/**
 * Paginated response interface
 */
export interface PaginatedResponse<T> {
  items: T[];
  continuationToken?: string;
  hasMore: boolean;
  count: number;
}

/**
 * Query trace information for logging
 */
interface QueryTrace {
  query: string;
  parameters?: Array<{ name: string; value: string | number | boolean }>;
  requestCharge: number;
  executionTime: number;
  itemCount: number;
}

export class VulnerabilityDefenderRepository {
  private client: CosmosClient;
  private database: Database | null = null;
  private container: Container | null = null;
  private isInitialized: boolean = false;
  private readonly QUERY_TIMEOUT_MS = 30000; // 30 seconds

  constructor() {
    this.client = new CosmosClient({
      endpoint: config.cosmos.endpoint,
      key: config.cosmos.key
    });
  }

  /**
   * Creates a timeout promise that rejects after specified milliseconds
   */
  private createTimeoutPromise(timeoutMs: number): Promise<never> {
    return new Promise((_, reject) => {
      setTimeout(() => {
        reject(new ServiceError(`Query timeout exceeded (${timeoutMs}ms). Please refine your query.`));
      }, timeoutMs);
    });
  }

  /**
   * Initialize database and container connections
   */
  private async ensureInitialized(): Promise<void> {
    if (this.isInitialized) {
      return;
    }

    try {
      this.database = this.client.database(config.cosmos.databaseId);
      this.container = this.database.container(config.cosmos.vulnerabilitiesDefenderContainerId);
      this.isInitialized = true;

      logger.info('[CosmosDB] VulnerabilityDefender repository initialized successfully', {
        database: config.cosmos.databaseId,
        container: config.cosmos.vulnerabilitiesDefenderContainerId
      });
    } catch (error) {
      logger.error('[CosmosDB] Failed to initialize VulnerabilityDefender repository', error as Error);
      throw new ServiceError('Database initialization failed');
    }
  }

  /**
   * Get container instance
   */
  private async getContainer(): Promise<Container> {
    await this.ensureInitialized();
    if (!this.container) {
      throw new ServiceError('Container not initialized');
    }
    return this.container;
  }

  /**
   * Log query execution trace
   */
  private logQueryTrace(trace: QueryTrace): void {
    logger.info('[CosmosDB Query Trace]', {
      query: trace.query,
      parameters: trace.parameters,
      requestCharge: `${trace.requestCharge.toFixed(2)} RU`,
      executionTime: `${trace.executionTime}ms`,
      itemCount: trace.itemCount,
      timestamp: new Date().toISOString()
    });
  }

  /**
   * Get vulnerability by ID
   */
  async getById(id: string): Promise<VulnerabilityDefender> {
    const startTime = Date.now();

    try {
      const container = await this.getContainer();

      logger.info('[CosmosDB] Fetching vulnerability by ID', { id });

      // Add timeout protection
      const readPromise = container.item(id, id).read<VulnerabilityDefenderDocument>();
      const response = await Promise.race([
        readPromise,
        this.createTimeoutPromise(this.QUERY_TIMEOUT_MS)
      ]);

      const executionTime = Date.now() - startTime;

      // Log trace
      this.logQueryTrace({
        query: `Point read: id=${id}`,
        requestCharge: response.requestCharge || 0,
        executionTime,
        itemCount: response.resource ? 1 : 0
      });

      if (!response.resource) {
        logger.warn('[CosmosDB] Vulnerability not found', { id });
        throw new NotFoundError('Vulnerability', id);
      }

      logger.info('[CosmosDB] Vulnerability fetched successfully', {
        id,
        executionTime: `${executionTime}ms`
      });

      return this.mapToVulnerability(response.resource);
    } catch (error) {
      const executionTime = Date.now() - startTime;

      if (error instanceof NotFoundError) {
        throw error;
      }

      // Handle 404 from CosmosDB
      if ((error as { code?: number }).code === 404) {
        logger.warn('[CosmosDB] Vulnerability not found (404)', { id, executionTime: `${executionTime}ms` });
        throw new NotFoundError('Vulnerability', id);
      }

      // Handle 409 Conflict errors
      if ((error as { code?: number }).code === 409) {
        logger.error('[CosmosDB] Conflict error (409)', error as Error, { id });
        throw new ConflictError('Conflict occurred while accessing vulnerability');
      }

      // Handle 429 Throttling
      if ((error as { code?: number }).code === 429) {
        const retryAfter = (error as any).retryAfterInMilliseconds || 1000;
        logger.error('[CosmosDB] Request throttled (429)', error as Error, {
          id,
          retryAfter: `${retryAfter}ms`
        });
        throw new ServiceError('Service temporarily unavailable, please retry', {
          retryAfter
        });
      }

      logger.error('[CosmosDB] Failed to fetch vulnerability', error as Error, {
        id,
        errorCode: (error as { code?: number }).code,
        executionTime: `${executionTime}ms`
      });

      throw new ServiceError('Failed to fetch vulnerability');
    }
  }

  /**
   * Get all vulnerabilities with optional filtering and pagination
   * Uses parameterized queries to prevent SQL injection
   */
  async getAll(
    filter?: {
      name?: string;
      severity?: string[];
      updatedOnFrom?: string;
      updatedOnTo?: string;
    },
    options?: {
      pageSize?: number;
      continuationToken?: string;
    }
  ): Promise<PaginatedResponse<VulnerabilityDefender>> {
    const startTime = Date.now();

    try {
      // Validate filter inputs
      if (filter?.severity) {
        for (const sev of filter.severity) {
          if (!VulnerabilityValidation.isValidSeverity(sev)) {
            throw new ValidationError(
              `Invalid severity value: ${sev}. Must be one of: Low, Medium, High, Critical`
            );
          }
        }
      }

      // Validate date formats (ISO 8601)
      if (filter?.updatedOnFrom && isNaN(Date.parse(filter.updatedOnFrom))) {
        throw new ValidationError(
          `Invalid updatedOnFrom format: ${filter.updatedOnFrom}. Must be a valid ISO 8601 date string`
        );
      }

      if (filter?.updatedOnTo && isNaN(Date.parse(filter.updatedOnTo))) {
        throw new ValidationError(
          `Invalid updatedOnTo format: ${filter.updatedOnTo}. Must be a valid ISO 8601 date string`
        );
      }

      const container = await this.getContainer();

      // Set pagination defaults
      const pageSize = Math.min(options?.pageSize || 50, 100); // Max 100 items per page

      let query = 'SELECT * FROM c ';
      const conditions: string[] = [];
      const parameters: { name: string; value: string | number | boolean }[] = [];

      // Build parameterized query to prevent SQL injection
      // NOTE: Documents use nested structure with all fields under c.value.fieldName or c["value"]["fieldName"]

      if (filter?.name) {
        conditions.push('CONTAINS(LOWER(c["value"]["name"]), LOWER(@name))');
        parameters.push({ name: '@name', value: filter.name });
      }

      if (filter?.severity && filter.severity.length > 0) {
        const severityConditions = filter.severity.map((_, index) => {
          const paramName = `@severity${index}`;
          parameters.push({ name: paramName, value: filter.severity![index] });
          return `c["value"]["severity"] = ${paramName}`;
        });
        conditions.push(`(${severityConditions.join(' OR ')})`);
      }

      if (filter?.updatedOnFrom) {
        conditions.push('c["value"]["updatedOn"] >= @updatedOnFrom');
        parameters.push({ name: '@updatedOnFrom', value: filter.updatedOnFrom });
      }

      if (filter?.updatedOnTo) {
        conditions.push('c["value"]["updatedOn"] <= @updatedOnTo');
        parameters.push({ name: '@updatedOnTo', value: filter.updatedOnTo });
      }

      // Build WHERE clause
      if (conditions.length > 0) {
        query += ' WHERE ' + conditions.join(' AND ');
      }

      // NOTE: ORDER BY removed - CosmosDB provides continuation tokens without explicit ordering
      // If you need specific ordering, create a composite index in Azure Portal first
      // Example: query += ' ORDER BY c["value"]["updatedOn"] DESC';

      logger.info('[CosmosDB] Executing vulnerability query with pagination', {
        filter,
        pageSize,
        hasContinuationToken: !!options?.continuationToken
      });

      logger.info(`QUERY EXE: ${query}`);
      // Execute query with pagination and timeout protection
      const queryIterator = container.items.query<VulnerabilityDefenderDocument>(
        {
          query: query,
          parameters: parameters
        },
        {
          maxItemCount: pageSize,
          continuationToken: options?.continuationToken
        }
      );

      const queryPromise = queryIterator.fetchNext();
      const response = await Promise.race([
        queryPromise,
        this.createTimeoutPromise(this.QUERY_TIMEOUT_MS)
      ]);

      const executionTime = Date.now() - startTime;

      // Log query trace
      this.logQueryTrace({
        query,
        parameters,
        requestCharge: response.requestCharge || 0,
        executionTime,
        itemCount: response.resources.length
      });

      logger.info('[CosmosDB] Vulnerability query executed successfully', {
        itemCount: response.resources.length,
        hasMore: response.hasMoreResults,
        hasContinuationToken: !!response.continuationToken,
        continuationTokenLength: response.continuationToken?.length || 0,
        requestCharge: `${(response.requestCharge || 0).toFixed(2)} RU`,
        executionTime: `${executionTime}ms`
      });

      // Debug: Log continuation token details
      if (response.hasMoreResults && !response.continuationToken) {
        logger.warn('[CosmosDB] WARNING: hasMoreResults=true but no continuationToken returned!', {
          query,
          pageSize,
          itemCount: response.resources.length
        });
      }

      return {
        items: response.resources.map(resource => this.mapToVulnerability(resource)),
        continuationToken: response.continuationToken,
        hasMore: response.hasMoreResults,
        count: response.resources.length
      };
    } catch (error) {
      const executionTime = Date.now() - startTime;

      // Preserve ValidationError
      if (error instanceof ValidationError) {
        throw error;
      }

      // Handle 409 Conflict errors
      if ((error as { code?: number }).code === 409) {
        logger.error('[CosmosDB] Conflict error (409) during vulnerability query', error as Error, {
          filter,
          executionTime: `${executionTime}ms`
        });
        throw new ConflictError('Conflict occurred while querying vulnerabilities');
      }

      // Handle 429 Throttling
      if ((error as { code?: number }).code === 429) {
        const retryAfter = (error as any).retryAfterInMilliseconds || 1000;
        logger.error('[CosmosDB] Request throttled (429) during vulnerability query', error as Error, {
          filter,
          retryAfter: `${retryAfter}ms`,
          executionTime: `${executionTime}ms`
        });
        throw new ServiceError('Service temporarily unavailable, please retry', {
          retryAfter
        });
      }

      logger.error('[CosmosDB] Vulnerability query failed', error as Error, {
        filter,
        errorCode: (error as { code?: number }).code,
        executionTime: `${executionTime}ms`
      });

      throw new ServiceError('Failed to fetch vulnerabilities');
    }
  }

  /**
   * Create a new vulnerability
   */
  async create(data: CreateVulnerabilityRequest): Promise<VulnerabilityDefender> {
    const startTime = Date.now();

    try {
      // Validate required fields
      if (!data.name || !data.severity || !data.updatedOn) {
        throw new ValidationError('Missing required fields: name, severity, and updatedOn are required');
      }

      // Validate severity
      if (!VulnerabilityValidation.isValidSeverity(data.severity)) {
        throw new ValidationError(
          `Invalid severity value: ${data.severity}. Must be one of: Low, Medium, High, Critical`
        );
      }

      // Validate CVSS score if provided
      if (data.cvssV3 !== undefined && !VulnerabilityValidation.isValidCvssScore(data.cvssV3)) {
        throw new ValidationError('Invalid cvssV3 score. Must be between 0 and 10');
      }

      // Validate date format
      if (isNaN(Date.parse(data.updatedOn))) {
        throw new ValidationError(
          `Invalid updatedOn format: ${data.updatedOn}. Must be a valid ISO 8601 date string`
        );
      }

      const container = await this.getContainer();

      // Generate unique ID
      const id = uuidv4();

      // Create document with nested structure
      const document: VulnerabilityDefenderDocument = {
        id,
        value: {
          id,
          ...data
        }
      };

      logger.info('[CosmosDB] Creating vulnerability', { id, name: data.name });

      const createPromise = container.items.create(document);
      const response = await Promise.race([
        createPromise,
        this.createTimeoutPromise(this.QUERY_TIMEOUT_MS)
      ]);

      const executionTime = Date.now() - startTime;

      this.logQueryTrace({
        query: `Create vulnerability: id=${id}`,
        requestCharge: response.requestCharge || 0,
        executionTime,
        itemCount: 1
      });

      logger.info('[CosmosDB] Vulnerability created successfully', {
        id,
        executionTime: `${executionTime}ms`
      });

      return this.mapToVulnerability(response.resource);
    } catch (error) {
      const executionTime = Date.now() - startTime;

      // Preserve ValidationError
      if (error instanceof ValidationError) {
        throw error;
      }

      // Handle 409 Conflict errors (duplicate ID)
      if ((error as { code?: number }).code === 409) {
        logger.error('[CosmosDB] Conflict error (409) during vulnerability creation', error as Error, {
          name: data.name,
          executionTime: `${executionTime}ms`
        });
        throw new ConflictError('Vulnerability with this ID already exists');
      }

      // Handle 429 Throttling
      if ((error as { code?: number }).code === 429) {
        const retryAfter = (error as any).retryAfterInMilliseconds || 1000;
        logger.error('[CosmosDB] Request throttled (429) during vulnerability creation', error as Error, {
          name: data.name,
          retryAfter: `${retryAfter}ms`,
          executionTime: `${executionTime}ms`
        });
        throw new ServiceError('Service temporarily unavailable, please retry', {
          retryAfter
        });
      }

      logger.error('[CosmosDB] Failed to create vulnerability', error as Error, {
        name: data.name,
        errorCode: (error as { code?: number }).code,
        executionTime: `${executionTime}ms`
      });

      throw new ServiceError('Failed to create vulnerability');
    }
  }

  /**
   * Update an existing vulnerability
   */
  async update(id: string, data: UpdateVulnerabilityRequest): Promise<VulnerabilityDefender> {
    const startTime = Date.now();

    try {
      // Validate severity if provided
      if (data.severity && !VulnerabilityValidation.isValidSeverity(data.severity)) {
        throw new ValidationError(
          `Invalid severity value: ${data.severity}. Must be one of: Low, Medium, High, Critical`
        );
      }

      // Validate CVSS score if provided
      if (data.cvssV3 !== undefined && !VulnerabilityValidation.isValidCvssScore(data.cvssV3)) {
        throw new ValidationError('Invalid cvssV3 score. Must be between 0 and 10');
      }

      // Validate date format if provided
      if (data.updatedOn && isNaN(Date.parse(data.updatedOn))) {
        throw new ValidationError(
          `Invalid updatedOn format: ${data.updatedOn}. Must be a valid ISO 8601 date string`
        );
      }

      const container = await this.getContainer();

      logger.info('[CosmosDB] Updating vulnerability', { id });

      // First, read the existing document
      const readResponse = await container.item(id, id).read<VulnerabilityDefenderDocument>();

      if (!readResponse.resource) {
        throw new NotFoundError('Vulnerability', id);
      }

      // Merge existing data with updates
      const existingValue = readResponse.resource.value || {} as VulnerabilityDefenderData;
      const updatedValue: VulnerabilityDefenderData = {
        ...existingValue,
        ...data,
        id // Ensure ID remains unchanged
      };

      // Update document
      const updatedDocument: VulnerabilityDefenderDocument = {
        ...readResponse.resource,
        value: updatedValue
      };

      const updatePromise = container.item(id, id).replace(updatedDocument);
      const response = await Promise.race([
        updatePromise,
        this.createTimeoutPromise(this.QUERY_TIMEOUT_MS)
      ]);

      const executionTime = Date.now() - startTime;

      this.logQueryTrace({
        query: `Update vulnerability: id=${id}`,
        requestCharge: response.requestCharge || 0,
        executionTime,
        itemCount: 1
      });

      logger.info('[CosmosDB] Vulnerability updated successfully', {
        id,
        executionTime: `${executionTime}ms`
      });

      return this.mapToVulnerability(response.resource);
    } catch (error) {
      const executionTime = Date.now() - startTime;

      // Preserve ValidationError and NotFoundError
      if (error instanceof ValidationError || error instanceof NotFoundError) {
        throw error;
      }

      // Handle 404 from CosmosDB
      if ((error as { code?: number }).code === 404) {
        logger.warn('[CosmosDB] Vulnerability not found (404) during update', {
          id,
          executionTime: `${executionTime}ms`
        });
        throw new NotFoundError('Vulnerability', id);
      }

      // Handle 409 Conflict errors
      if ((error as { code?: number }).code === 409) {
        logger.error('[CosmosDB] Conflict error (409) during vulnerability update', error as Error, {
          id,
          executionTime: `${executionTime}ms`
        });
        throw new ConflictError('Conflict occurred while updating vulnerability');
      }

      // Handle 429 Throttling
      if ((error as { code?: number }).code === 429) {
        const retryAfter = (error as any).retryAfterInMilliseconds || 1000;
        logger.error('[CosmosDB] Request throttled (429) during vulnerability update', error as Error, {
          id,
          retryAfter: `${retryAfter}ms`,
          executionTime: `${executionTime}ms`
        });
        throw new ServiceError('Service temporarily unavailable, please retry', {
          retryAfter
        });
      }

      logger.error('[CosmosDB] Failed to update vulnerability', error as Error, {
        id,
        errorCode: (error as { code?: number }).code,
        executionTime: `${executionTime}ms`
      });

      throw new ServiceError('Failed to update vulnerability');
    }
  }

  /**
   * Delete a vulnerability
   */
  async delete(id: string): Promise<void> {
    const startTime = Date.now();

    try {
      const container = await this.getContainer();

      logger.info('[CosmosDB] Deleting vulnerability', { id });

      const deletePromise = container.item(id, id).delete();
      const response = await Promise.race([
        deletePromise,
        this.createTimeoutPromise(this.QUERY_TIMEOUT_MS)
      ]);

      const executionTime = Date.now() - startTime;

      this.logQueryTrace({
        query: `Delete vulnerability: id=${id}`,
        requestCharge: response.requestCharge || 0,
        executionTime,
        itemCount: 0
      });

      logger.info('[CosmosDB] Vulnerability deleted successfully', {
        id,
        executionTime: `${executionTime}ms`
      });
    } catch (error) {
      const executionTime = Date.now() - startTime;

      // Handle 404 from CosmosDB
      if ((error as { code?: number }).code === 404) {
        logger.warn('[CosmosDB] Vulnerability not found (404) during delete', {
          id,
          executionTime: `${executionTime}ms`
        });
        throw new NotFoundError('Vulnerability', id);
      }

      // Handle 409 Conflict errors
      if ((error as { code?: number }).code === 409) {
        logger.error('[CosmosDB] Conflict error (409) during vulnerability delete', error as Error, {
          id,
          executionTime: `${executionTime}ms`
        });
        throw new ConflictError('Conflict occurred while deleting vulnerability');
      }

      // Handle 429 Throttling
      if ((error as { code?: number }).code === 429) {
        const retryAfter = (error as any).retryAfterInMilliseconds || 1000;
        logger.error('[CosmosDB] Request throttled (429) during vulnerability delete', error as Error, {
          id,
          retryAfter: `${retryAfter}ms`,
          executionTime: `${executionTime}ms`
        });
        throw new ServiceError('Service temporarily unavailable, please retry', {
          retryAfter
        });
      }

      logger.error('[CosmosDB] Failed to delete vulnerability', error as Error, {
        id,
        errorCode: (error as { code?: number }).code,
        executionTime: `${executionTime}ms`
      });

      throw new ServiceError('Failed to delete vulnerability');
    }
  }

  /**
   * Check if vulnerability exists
   */
  async exists(id: string): Promise<boolean> {
    try {
      await this.getById(id);
      return true;
    } catch (error) {
      if (error instanceof NotFoundError) {
        return false;
      }
      throw error;
    }
  }

  /**
   * Map CosmosDB document to VulnerabilityDefender model
   * CosmosDB documents have a nested structure where all fields are under "value" property
   * We need to extract and flatten the structure for the API response
   */
  private mapToVulnerability(doc: any): VulnerabilityDefender {
    // Documents are stored with nested structure: { id, value: { ...fields }, _rid, _etag, _ts }
    // Extract the value object and merge with document-level metadata
    const value = doc.value || {};

    const result: any = {
      id: doc.id,
      ...value
    };

    // Preserve CosmosDB metadata only if present (avoid adding undefined fields)
    if (doc._rid !== undefined) result._rid = doc._rid;
    if (doc._self !== undefined) result._self = doc._self;
    if (doc._etag !== undefined) result._etag = doc._etag;
    if (doc._attachments !== undefined) result._attachments = doc._attachments;
    if (doc._ts !== undefined) result._ts = doc._ts;

    return result as VulnerabilityDefender;
  }
}

// Export singleton instance
export const vulnerabilityDefenderRepository = new VulnerabilityDefenderRepository();
