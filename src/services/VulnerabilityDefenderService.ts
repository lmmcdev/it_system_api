/**
 * VulnerabilityDefender service layer
 * Contains business logic for VulnerabilityDefender operations
 */

import {
  VulnerabilityDefender,
  CreateVulnerabilityRequest,
  UpdateVulnerabilityRequest
} from '../models/VulnerabilityDefender';
import {
  vulnerabilityDefenderRepository,
  PaginatedResponse
} from '../repositories/VulnerabilityDefenderRepository';
import { logger } from '../utils/logger';

export class VulnerabilityDefenderService {
  /**
   * Get vulnerability by ID
   */
  async getVulnerabilityById(id: string): Promise<VulnerabilityDefender> {
    logger.info('Service: Fetching vulnerability by ID', { id });

    const vulnerability = await vulnerabilityDefenderRepository.getById(id);

    logger.info('Service: Vulnerability fetched successfully', { id });

    return vulnerability;
  }

  /**
   * Get all vulnerabilities with optional filtering and pagination
   */
  async getAllVulnerabilities(
    filter?: {
      name?: string;
      severity?: string[];
      updatedOnFrom?: string;
      updatedOnTo?: string;
    },
    options?: {
      pageSize?: number;
      continuationToken?: string;
    }
  ): Promise<PaginatedResponse<VulnerabilityDefender>> {
    logger.info('Service: Fetching all vulnerabilities', { filter, options });

    const result = await vulnerabilityDefenderRepository.getAll(filter, options);

    logger.info('Service: Vulnerabilities fetched successfully', {
      count: result.count,
      hasMore: result.hasMore
    });

    return result;
  }

  /**
   * Create a new vulnerability
   */
  async createVulnerability(data: CreateVulnerabilityRequest): Promise<VulnerabilityDefender> {
    logger.info('Service: Creating vulnerability', { name: data.name });

    const vulnerability = await vulnerabilityDefenderRepository.create(data);

    logger.info('Service: Vulnerability created successfully', { id: vulnerability.id });

    return vulnerability;
  }

  /**
   * Update an existing vulnerability
   */
  async updateVulnerability(
    id: string,
    data: UpdateVulnerabilityRequest
  ): Promise<VulnerabilityDefender> {
    logger.info('Service: Updating vulnerability', { id });

    const vulnerability = await vulnerabilityDefenderRepository.update(id, data);

    logger.info('Service: Vulnerability updated successfully', { id });

    return vulnerability;
  }

  /**
   * Delete a vulnerability
   */
  async deleteVulnerability(id: string): Promise<void> {
    logger.info('Service: Deleting vulnerability', { id });

    await vulnerabilityDefenderRepository.delete(id);

    logger.info('Service: Vulnerability deleted successfully', { id });
  }

  /**
   * Check if vulnerability exists
   */
  async vulnerabilityExists(id: string): Promise<boolean> {
    logger.info('Service: Checking if vulnerability exists', { id });

    const exists = await vulnerabilityDefenderRepository.exists(id);

    logger.info('Service: Vulnerability existence checked', { id, exists });

    return exists;
  }
}

// Export singleton instance
export const vulnerabilityDefenderService = new VulnerabilityDefenderService();
