/**
 * Azure Function: Create Vulnerability
 * HTTP POST endpoint to create a new vulnerability
 */

import { app, HttpRequest, HttpResponseInit, InvocationContext } from '@azure/functions';
import { vulnerabilityDefenderService } from '../services/VulnerabilityDefenderService';
import { handleError, successResponse, ValidationError } from '../utils/errorHandler';
import { logger } from '../utils/logger';
import { validateFunctionKey } from '../middleware/authentication';
import { checkRateLimit, createRateLimitResponse, RATE_LIMITS } from '../middleware/rateLimit';
import { CreateVulnerabilityRequest } from '../models/VulnerabilityDefender';

async function createVulnerability(
  request: HttpRequest,
  context: InvocationContext
): Promise<HttpResponseInit> {
  try {
    logger.setContext({
      functionName: context.functionName,
      invocationId: context.invocationId
    });

    logger.info('Processing create vulnerability request');

    // Authentication check
    const authResult = validateFunctionKey(request);
    if (!authResult.authenticated) {
      logger.warn('Authentication failed', { error: authResult.error });
      return {
        status: 401,
        jsonBody: {
          success: false,
          error: {
            code: 'AUTHENTICATION_FAILED',
            message: authResult.error || 'Authentication required'
          },
          timestamp: new Date().toISOString()
        },
        headers: {
          'Content-Type': 'application/json',
          'WWW-Authenticate': 'FunctionKey'
        }
      };
    }

    logger.info('Authentication successful', { userId: authResult.userId });

    // Rate limiting check
    const rateLimitResult = checkRateLimit(request, 'create', RATE_LIMITS.create);
    if (!rateLimitResult.allowed) {
      return createRateLimitResponse(rateLimitResult);
    }

    // Parse request body
    const body = await request.text();
    if (!body) {
      throw new ValidationError('Request body is required');
    }

    let data: CreateVulnerabilityRequest;
    try {
      data = JSON.parse(body) as CreateVulnerabilityRequest;
    } catch (parseError) {
      logger.warn('Failed to parse request body', { error: parseError });
      throw new ValidationError('Invalid JSON in request body');
    }

    // Validate required fields
    if (!data.name) {
      throw new ValidationError('Missing required field: name');
    }

    if (!data.severity) {
      throw new ValidationError('Missing required field: severity');
    }

    if (!data.updatedOn) {
      throw new ValidationError('Missing required field: updatedOn');
    }

    logger.info('Request validation successful', { name: data.name, severity: data.severity });

    // Create vulnerability
    const vulnerability = await vulnerabilityDefenderService.createVulnerability(data);

    logger.info('Vulnerability created successfully', { id: vulnerability.id });

    return successResponse(vulnerability, 201);
  } catch (error) {
    return handleError(error, context, request);
  } finally {
    logger.clearContext();
  }
}

app.http('createVulnerability', {
  methods: ['POST'],
  authLevel: 'anonymous',
  route: 'vulnerabilities',
  handler: createVulnerability
});
